## Programming assignment 2 presents a pair of functions: 'makeCacheMatrix' and 'cacheSolve' that cache the inverse of a SQUARE, INVERTIBLE matrix (x).
## 'makeCacheMatrix' creates a matrix that caches its inverse and returns a list of functions; 'cacheSolve' uses the returned list to get (extract) or set (create) the inverted matrix in cache.

## (1) makeCacheMatrix - a function that creates a special "matrix" object that can cache its inverse.

makeCacheMatrix <- function(x = matrix()) {
        ## Return cached inverse of matrix, x.

        ## x is a square, invertible matrix, i.e., det(x) != 0 (x is nonsingular)
        ## initialize and store the cached value to NULL in object "cache"
        cache <- NULL

        ## (1) set the matrix in the working environment
        set <- function(y) {
                x <<- y
                cache <<- NULL
                ## NB: The special assignment operator, <<-, is used to update the value(s)
                ## of objects returned within a closure (any number of functions embedded
                ## within a function). e.g., x <<- y will update x in the global/top-level
                ## environment, which is accessible by every function in the closure
        }

        ## (ii) get the value of the matrix, x.
        get <- function() x

        ## (iii) set or invert matrix, x, and assign result to object "cache"
        setMatrix <- function(inverse) cache <<- inverse

        ## (iv) get the cached inverse of matrix, x, from object "cache"
        getInverse <- function() cache

        ## (v) return a list containing functions created by function
        ## makeCacheMatrix; (set, get, setMatrix and getInverse) to the working
        ## environment, for use by function 'cacheSolve', below.
        list(set = set, get = get,
             setMatrix = setMatrix,
             getInverse = getInverse)
}


## (2) cacheSolve - a function that computes the inverse of the special "matrix" returned by makeCacheMatrix above. If the inverse has already been calculated (and the matrix has not changed), then cacheSolve retrieves the inverse from the cache.

## If the inverted matrix does not exist in cache, 'cacheSolve' extracts matrix, x, from a function in the list generated by 'makeCacheMatrix' above and creates the inverse of 'x' in the working environment of the closure.

cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of matrix, x.

        # (1) get the inverse of the matrix, x, stored in the cache, using the
        # 'getInverse' function in 'makeCacheMatrix' closure above
        inv <- x$getInverse()

        # (2a) check if inverted matrix "inv" exists in the global environment
        if (!is.null(inv)) {
                message("getting cached data from function; makeCacheMatrix.")
                return(inv) # display matrix in console
        }
        else{
                # (2b)  else if cached matrix, inv, doesn't exist, obtain the original
                # matrix, x, so we can create "inv" in the working environment
                matrix <- x$get() ## use the 'get' function in 'makeCacheMatrix' closure
        }

        # (3) check that "matrix" is square and invertible, and create "inv" from
        # inverted matrix. If not, handle errors or exceptions cleanly
        tryCatch({
                # (3a) solve and return inverse of "matrix", using R's solve' function
                inv <- solve(matrix, ...)
        },
        error = function(e) {
                message("Error:")
                message(e)
                return(NA)
        },
        warning = function(e) {
                message("Warning:")
                message(e)
                return(NA)
        },
        finally = {
                # (3b) use "inv" to reset inverted matrix in cache, using the 'setMatrix'
                #function in 'makeCacheMatrix' closure above
                x$setMatrix(inv)
        })

        # (3c) display matrix in console
        return (inv)
}

## == == == == == == == == == == == == == == == == == == == == == == == == ==

## TEST using:
## > mat <- makeCacheMatrix()
## > mat$set(matrix(runif(25,1,50), 5, 5))
## > cacheSolve(mat)
# I've used 'runif' to randomly generate a 25 element vector with 1<=values<=50.

## CALL 1 of cacheSolve(mat)
## > cacheSolve(mat)
# [,1]        [,2]          [,3]        [,4]        [,5]
# [1,] -0.009682496 -0.00532496  0.0009260422 -0.02694682  0.03995137
# [2,] -0.096656962  0.07402854  0.0129905354 -0.11990202  0.09171000
# [3,]  0.116464073 -0.09203154  0.0137837026  0.15036553 -0.12058116
# [4,]  0.059037599 -0.01225289  0.0088976049  0.02588665 -0.04896870
# [5,] -0.052953275  0.04734311 -0.0258905156 -0.02751928  0.04007516

## CALL 2 of cacheSolve(mat)
## > cacheSolve(mat)
# getting cached data from function; makeCacheMatrix.
# [,1]        [,2]          [,3]        [,4]        [,5]
# [1,] -0.009682496 -0.00532496  0.0009260422 -0.02694682  0.03995137
# [2,] -0.096656962  0.07402854  0.0129905354 -0.11990202  0.09171000
# [3,]  0.116464073 -0.09203154  0.0137837026  0.15036553 -0.12058116
# [4,]  0.059037599 -0.01225289  0.0088976049  0.02588665 -0.04896870
# [5,] -0.052953275  0.04734311 -0.0258905156 -0.02751928  0.04007516